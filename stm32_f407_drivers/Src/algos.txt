/******************************************************************************************
 *								I2C APIs and Support Functions
 								     Bare Metal Algorithms
 *		 
 ******************************************************************************************/
1. void I2C_Init(I2C_Handle_t *pI2CHandle)

	• Enable the peripheral Clock
	• Configure the ACKing mechanism
	• Configure the freq field values, which is the value for the frequency at which the peripheral clock 
	runs at.
	• Write the device's own address in the OAR1 and 2 if needed
	• Enter the CCR value  - 
		○ If standard mode, ccr_value = PCLK1_Value/2*input speed 
		○ If fast mode, check the DUTY bit.
			§ For (2) - ccr_value = PCLK1_Value/3*input speed 
			§ For (16/9) - ccr_value = PCLK1_Value/25*input speed 
	• Then, configure the TRISE value
		○ For SM, TRISE = (F(pclk1)*1,000)/1,00,00,00,000)+1
		○ For FM, TRISE = (F(pclk1)*300)/1,00,00,00,000)+1
	
/************************************************************************************************************************************************************************/

2. void I2C_MasterSendData(I2C_Handle_t *pI2CHandle,uint8_t *pTxbuffer, uint32_t Len, uint8_t SlaveAddr, uint8_t Sr) 
	• Generate the start condition
	• Confirm that start generation is completed by checking the SB flag in the SR.
     Note: Until SB is cleared SCL will be stretched (pulled to LOW)
	• Send the address of the slave with r/nw bit set to w(0) (total 8 bits )
	• Confirm that the address phase is completed by checking the ADDR flag in the SR1
	Clear the ADDR flag according to its software sequence.
	 Note: Until ADDR is cleared SCL will be stretched (pulled to LOW)
	• Send the data until len becomes 0
	• When Len becomes zero wait for TXE=1 and BTF=1 before generating the STOP condition Note: TXE=1 , BTF=1 , means that both SR and DR are empty and next transmission should begin  when BTF=1 SCL will be stretched (pulled to LOW)
	• Generate STOP condition and master need not to wait for the completion of stop condition. Note: generating STOP, automatically clears the BTF

/************************************************************************************************************************************************************************/

3.void I2C_MasterReceiveData(I2C_Handle_t *pI2CHandle,uint8_t *pRxBuffer, uint8_t Len, uint8_t SlaveAddr,uint8_t Sr)
	• Generate the start condition
	• Confirm that start generation is completed by checking the SB flag in the SR.
	•      Note: Until SB is cleared SCL will be stretched (pulled to LOW)
	• Send the address of the slave with r/nw bit set to w(0) (total 8 bits )
	• Confirm that the address phase is completed by checking the ADDR flag in the SR1
	• To read ONLY 1 BYTE FROM SLAVE 
		○ Disable Acking
		○ Clear the ADDR flag
		○ Wait till the RxNE == 1
		○ Generate the Stop Condition
		○ Read the Buffer Data
	• To read multiple bytes of Data
		○ Clear the ADDR flag
		○ Read till len==0
		○ Wait till RxNE==1
			§ For the last 2 bytes remaining
				□ Disable the ACKING
				□ Generate the Stop condition]
			§ Read the Data Buffer
			§ Increment the buffer address
	• Re-enable the ACKing

/************************************************************************************************************************************************************************/

	
4. uint8_t I2C_MasterSendDataIT(I2C_Handle_t *pI2CHandle,uint8_t *pTxBuffer, uint32_t Len, uint8_t SlaveAddr,uint8_t Sr)
	
	• Update the handle structure with the corresponding variables from the argument list
	• Generate the start condition
	• Enable the ITBUFEN bit in the CR-2
	• Enable the ITEVFEN bit in the Cr-2
	• Enable the ITERREN bit in the CR-2
	• The code to send the data is handled in the application by the ISR

/************************************************************************************************************************************************************************/
	
5. uint8_t I2C_MasterReceiveDataIT(I2C_Handle_t *pI2CHandle,uint8_t *pRxBuffer, uint8_t Len, uint8_t SlaveAddr,uint8_t Sr)

	• Update the handle structure with the corresponding variables from the argument list
	• Generate the start condition
	• Enable the ITBUFEN bit in the CR-2
	• Enable the ITEVFEN bit in the Cr-2
	• Enable the ITERREN bit in the CR-2
	• The code to read the data is handled in the application by the ISR

/************************************************************************************************************************************************************************/
	
6. void I2C_EV_IRQHandling(I2C_Handle_t *pI2CHandle)
	
	• Interrupt handling for both master and slave mode of a device
	    
	• Handle For interrupt generated by SB event. Note : SB flag is only applicable in Master mode
	    
	• Handle For interrupt generated by ADDR event. Note : 
	     When master mode : Address is sent .
		When Slave mode  : Address matched with own address .
	    
	• Handle For interrupt generated by BTF(Byte Transfer Finished) event  
	    
	• Handle For interrupt generated by STOPF event. Note : 
		Stop detection flag is applicable only slave mode 
		For master this flag will never be set
	        
	• Handle For interrupt generated by TXE event 
	    
	• Handle For interrupt generated by RXNE event 

/************************************************************************************************************************************************************************/
	
7. void I2C_ER_IRQHandling(I2C_Handle_t *pI2CHandle)
	    uint32_t temp1,temp2;
	    Know the status of  ITERREN control bit in the CR2
	    temp2 = (pI2CHandle->pI2Cx->CR2) & ( 1 << I2C_CR2_ITERREN);
	
	/***********************Check for Bus error************************************/ 
	    temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1<< I2C_SR1_BERR);
	    if(temp1  && temp2 )
	    {
	        This is Bus error
	        
	        Implement the code to clear the buss error flag 
	        pI2CHandle->pI2Cx->SR1 &= ~( 1 << I2C_SR1_BERR);
	        
	        Implement the code to notify the application about the error 
	       I2C_ApplicationEventCallback(pI2CHandle,I2C_ERROR_BERR);
	    }
	/***********************Check for arbitration lost error************************************/ 
	    temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1 << I2C_SR1_ARLO );
	    if(temp1  && temp2)
	    {
	        This is arbitration lost error
	        
	        Implement the code to clear the arbitration lost error flag
	        
	        Implement the code to notify the application about the error 
	       
	    }
	/***********************Check for ACK failure  error************************************/ 
	    temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1 << I2C_SR1_AF);
	    if(temp1  && temp2)
	    {
	        This is ACK failure error
	        
	        Implement the code to clear the ACK failure error flag
	        
	        Implement the code to notify the application about the error 
	    }
	/***********************Check for Overrun/underrun error************************************/
	    temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1 << I2C_SR1_OVR);
	    if(temp1  && temp2)
	    {
	        This is Overrun/underrun
	        
	        Implement the code to clear the Overrun/underrun error flag
	        
	        Implement the code to notify the application about the error 
	    }
	/***********************Check for Time out error************************************/
	    temp1 = (pI2CHandle->pI2Cx->SR1) & ( 1 << I2C_SR1_TIMEOUT);
	    if(temp1  && temp2)
	    {
	        This is Time out error
	        
	        Implement the code to clear the Time out error flag
	        
	        Implement the code to notify the application about the error 
    }



/******************************************************************************************
 *								SPI APIs and Support Functions
 								     Bare Metal Algorithms
 *		 
 ******************************************************************************************/
	
/*
 * Peripheral Clock setup
 */
 
01. void SPI_PeriClockControl(SPI_RegDef_t *pSPIx, uint8_t EnorDi)
    -Check the EnorDi value. 
	-If ENABLE, then SPIx_PCLK_EN();
	-If DISABELE, then SPIx_PCLK_DI();

/************************************************************************************************************************************************************************/

/*
 * Init and De-init
 */
 
02. void SPI_Init(SPI_Handle_t *pSPIHandle)
	-Enable the peripheral clock
	-Configure the device mode in the CR1
	-Configure the bus type (FD, HD, Simplex)
		-For FD, clear the bidimode
		-For HD, set the bidimode
		-For SIMPLEX, clear the bidimode and set the RXONLY bit
	-Configure the SPI Clock speed
	-Configure the DFF
	-Configure the CPOL
	-Configure the CPHA

/************************************************************************************************************************************************************************/
	
03. void SPI_DeInit(SPI_RegDef_t *pSPIx)
	-Check the pSPIx
	-Call the REG_Reset API for the corresponding value

/************************************************************************************************************************************************************************/

/*
 * Data Send and Receive
 */
 
04. void SPI_SendData(SPI_RegDef_t *pSPIx,uint8_t *pTxBuffer, uint32_t Len)
While Len>0 - 
	-Wait till teh TxE bit is Set 
	-Check the DFF bit in the CR1
		-If the DFF = 1 - that means we have a 16 bit frame (2 bytes)
			-Load the data into the DR
			-Decrement the length by 2
			-Increment the pointer to the Tx Buffer by 2 (or once if you typecast it to (uint16_t))
		-If the DFF = 0 - that means we have a 8 bit frame (1 byte)
			-Load the data into the DR
			-Decrement the length by 1
			-Increment the pointer to the Tx Buffer by 1 

/************************************************************************************************************************************************************************/

05. void SPI_ReceiveData(SPI_RegDef_t *pSPIx, uint8_t *pRxBuffer, uint32_t Len)
While Len>0 - 
	-Wait till teh RxNE bit is Set 
	-Check the DFF bit in the CR1
		-If the DFF = 1 - that means we have a 16 bit frame (2 bytes)
			-Load the data from the DR to the Rx Buffer
			-Decrement the length by 2
			-Increment the pointer to the Rx Buffer by 2 (or once if you typecast it to (uint16_t))
		-If the DFF = 0 - that means we have a 8 bit frame (1 byte)
			-Load the data from the DR to the Rx Buffer
			-Decrement the length by 1
			-Increment the pointer to the Rx Buffer by 1 

/************************************************************************************************************************************************************************/

06. uint8_t SPI_SendDataIT(SPI_Handle_t *pSPIHandle,uint8_t *pTxBuffer, uint32_t Len)
	-Check the Txstate of the peripheral. Proceed ONLY if the state is !SPI_BUSY_IN_TX
	-Save the Tx Buffer address and the length information in some GLOBAL variables
	-Mark the SPI state as SPI_BUSY_IN_TX
	-Enable the TXEIE bit in the CR2
	-Return state

/************************************************************************************************************************************************************************/

07. uint8_t SPI_ReceiveDataIT(SPI_Handle_t *pSPIHandle, uint8_t *pRxBuffer, uint32_t Len)
	-Check the Rxstate of the peripheral. Proceed ONLY if the state is !SPI_BUSY_IN_RX
	-Save the Tx Buffer address and the length information in some GLOBAL variables
	-Mark the SPI state as SPI_BUSY_IN_RX
	-Enable the RXNEIE bit in the CR2
	-Return state

/************************************************************************************************************************************************************************/

/*
 * IRQ Configuration and ISR handling
 */
08. void SPI_IRQInterruptConfig(uint8_t IRQNumber, uint8_t EnorDi)
	-Check the En0rDi.
	-If ENABLE - 
		-Check the IRQNumber
		-If <=31 program the ISER0.
		-If >31 & <64 program the ISER1.
		-If >64 & <=95 program the ISER2.
	-If DISABLE - 
		-Check the IRQNumber
		-If <=31 program the ICER0.
		-If >31 & <64 program the ICER1.
		-If >64 & <=95 program the ICER2.

/************************************************************************************************************************************************************************/
		
09. void SPI_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority)
	-Gonna gatekeep the logic, look at the code you dumbass.

/************************************************************************************************************************************************************************/

10. void SPI_IRQHandling(SPI_Handle_t *pHandle)
	-Check and handle the TXE, RXNE, and the OVR

/************************************************************************************************************************************************************************/

/*
 * Other Peripheral Control APIs
 */
11. void SPI_PeripheralControl(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
	-Check the EnOrDi Value.
	-If ENABLE - 
		-Set the SPE bit as 1 in the CR1 Register of the corresponding SPI peripheral.
	-If DISABLE - 
		-Reset the SPE bit in the CR1 Register of the corresponding SPI peripheral.

/************************************************************************************************************************************************************************/

12. void SPI_SSIConfig(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
	-Check the EnOrDi Value.
	-If ENABLE - 
		-Set the SSI bit as 1 in the CR1 Register of the corresponding SPI peripheral.
	-If DISABLE - 
		-Reset the SSI bit in the CR1 Register of the corresponding SPI peripheral.

/************************************************************************************************************************************************************************/

13. void SPI_SSOEConfig(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
	-Check the EnOrDi Value.
	-If ENABLE - 
		-Set the SSOE bit as 1 in the CR1 Register of the corresponding SPI peripheral.
	-If DISABLE - 
		-Reset the SSOE bit in the CR1 Register of the corresponding SPI peripheral.

/************************************************************************************************************************************************************************/

14. uint8_t SPI_GetFlagStatus(SPI_RegDef_t *pSPIx , uint32_t FlagName)
15. void SPI_ClearOVRFlag(SPI_RegDef_t *pSPIx)
16. void SPI_CloseTransmisson(SPI_Handle_t *pSPIHandle)
17. void SPI_CloseReception(SPI_Handle_t *pSPIHandle)
18. uint8_t I2C_DeviceMode(I2C_RegDef_t *I2Cx)

/*
 * Application callback
 */
19. void SPI_ApplicationEventCallback(SPI_Handle_t *pSPIHandle,uint8_t AppEv)